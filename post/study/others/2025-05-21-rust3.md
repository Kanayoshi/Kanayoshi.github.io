---
layout: default
title: "rust3"
date: 2025-05-21
use_mathjax: true
# categories:
---

# Rustメモ(3)

## [4.1 所有権とは?](https://doc.rust-jp.rs/book-ja/ch04-01-what-is-ownership.html)

- Rustの所有権はガベージコレクションなしで安全性担保を行うことに寄与しているらしい
  - ガベージコレクションとは定期的に使用されていないメモリを検索する機能のこと
- 全てのプログラムは実行中にコンピュータのメモリの使用方法を管理する必要がある
  - 言語によって以下のパターンがある
    - ガベージコレクションを持つ (Pythonとか)
    - プログラマが明示的にメモリを確保したり, 開放したりする必要がある (C言語とか)
    - 所有権システムを通してメモリの使用方法を管理する (Rust)
- 所有権の理解を行うにあたり, スタックとヒープの違いが重要になってくるらしい
  - **スタック**：last in, fitst out. 上へ積み重ねていき, 一番上のデータのみ取り出せる. データを追加することをpush, データを取り除くことをpopという
  - **ヒープ**：動的（実行時）にメモリを割り当て, 任意の順序で開放できる記憶領域のこと. メモリの割当のことを allocating on the heap, もしくは単にallocateするという. allocateする際にはポインタを返す. 
  - ヒープデータを管理することが所有権の存在する理由（の一つ）らしい.

### 所有権規則
- Rustの各値は所有者と呼ばれる変数と対応している
- 常に所有者は一つ
- 所有者がスコープから外れたら, 値は破棄される

### 変数スコープ

- **スコープ**とは, 要素が有効になるプログラム内の範囲のこと.

```rust
{                      // sは、ここでは有効ではない。まだ宣言されていない
    let s = "hello";   // sは、ここから有効になる

    // sで作業をする
}                      // このスコープは終わり。もうsは有効ではない
```

### `String`型

- ここまで登場した型は全てスタックに保管され, スコープが終わるとスタックから取り除かれる.
- `String`型はヒープにメモリを確保する.
- 文字列リテラルは不変だが, それから生成された`String`型の文字列は可変化することができる.
 
```rust
// 二重コロンは`String`型直下の`from`関数を特定する働きを持つ演算子
// String::fromを呼んだ時点で, その実装が必要なメモリ要求する
let mut s = String::from("hello"); 

s.push_str(", world!"); // push_str()関数は、リテラルをStringに付け加える

println!("{}", s); // これは`hello, world!`と出力する

// `s` 変数がスコープを抜けるとき. `String`型が必要とするメモリをOSに変換する
// 変数がスコープを抜けるとき, Rustは特別な関数`drop`を呼ぶ. 
// ユーザーはメモリを変換するコードを配置することができる.
```

- メモリを手動で管理する場合, メモリの確保と開放は1対1に対応させる必要がある.
  - C言語の場合, `allocate`と`free`は1対1に対応させる必要があることに相当.
- 上記ルールを言い換えると, 以下の2つが必要になるということ.
  - メモリは, 実行時にOSに要求される.
  - 使用し終えたら, OSにメモリを返還する.
- 上記の2つ目に関して, ガベージコレクションつくの言語ではプログラマが考慮する必要がない (使用されないメモリを検知して片付けるため).

### ムーブとクローン

- Rustでは複数の変数が同じデータに対して異なる手段で相互作用することができる.
    - "shallow copy"に相当する相互参照がRustの**ムーブ**, "deep copy"に相当する相互参照がRustの**クローン**に相当する.
      - ただし, ムーブではコンパイラが最初の変数を無効化する（二重解放エラー防止のため）点が"shallow copy"と異なっている.
- 整数のようなコンパイル時に既知のサイズを持つ型は, スタック上にすっぽり保持されるため, 実際の値をコピーするのも高速であり, shallow copyとdeep copyの違いがなくなる.
  - Rustには`Copy`トレイトと呼ばれる特別な注釈があり. 整数のようなスタックに保持される型に対して配置することができる. 型が`Copy`トレイトに適合していれば, 代入後も古い変数が使用可能になる.
  - 単純なスカラー値の集合は`Copy`, メモリ確保が必要もしくは何らかの形態のリソースだったりするものは`Copy`ではない.`Copy`の型の一部は以下の通り
    - あらゆる整数型
    - 論理値型
    - あらゆる浮動小数点型
    - 文字列
    - `Copy`の型のみを含むタプル

```rust
// ムーブが使われている例
// 二重解放エラー回避のため、s2宣言時にs1が使っていたヒープメモリが片付けられる（無効になる）
let s1 = String::from("hello");
let s2 = s1; // これ以降はs2のみ有効

println!("{}, world!", s1); // s1二対応するヒープメモリ開放後にs1を用いようとしているため, エラーが生じる


// クローンが使われている例
// 実際にヒープデータがコピーされている
let s1 = String::from("hello");
let s3 = s1.clone();
println!("s1 = {}, s3 = {}", s1, s3); // ムーブではないため, s1も使える

// スタックのみのデータでshallow copyとdeep copyの区別がない例
let x = 5; //整数型は`Copy`トレイトに適合する
let y = x;
println!("x = {}, y = {}", x, y);
```

### 所有権と関数

- 関数に値を渡すことと値を変数に代入することは似ている.

```rust
fn main() {
    let s = String::from("hello");  // sがスコープに入る

    takes_ownership(s);             // sの値が関数にムーブされ...
                                    // ... ここではもう有効ではない

// takes_ownershipの呼び出し後にsを呼び出そうとすると, コンパイラはコンパイルエラーを投げる
    let x = 5;                      // xがスコープに入る

    makes_copy(x);                  // xも関数にムーブされるが...
                                    // i32はCopyなので, この後にxを使っても大丈夫

} // ここでxがスコープを抜け, sもスコープを抜ける. ただし, sの値はムーブされているので, 何も特別なことは起こらない.

fn takes_ownership(some_string: String) { // some_stringがスコープに入る.
    println!("{}", some_string);
} // ここでsome_stringがスコープを抜け, `drop`が呼ばれる。後ろ盾してたメモリが解放される.

fn makes_copy(some_integer: i32) { // some_integerがスコープに入る
    println!("{}", some_integer);
} // ここでsome_integerがスコープを抜ける.
```

### 戻り値とスコープ

- 値を返すことでも, 所有権は移動する.

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownershipは, 戻り値をs1にムーブする

    let s2 = String::from("hello");     // s2がスコープに入る

    let s3 = takes_and_gives_back(s2);  // s2はtakes_and_gives_backにムーブされ, 戻り値もs3にムーブされる
} // ここで, s3はスコープを抜けドロップされる. s2もスコープを抜けるが, ムーブされているので何も起きない. s1もスコープを抜けドロップされる.

fn gives_ownership() -> String {             // gives_ownershipは, 戻り値を呼び出した関数にムーブする
    let some_string = String::from("hello"); // some_stringがスコープに入る

    some_string                              // some_stringが返され、呼び出し元関数にムーブされる
}

// takes_and_gives_backは, Stringを一つ受け取り, 返す.
fn takes_and_gives_back(a_string: String) -> String { // a_stringがスコープに入る。

    a_string  // a_stringが返され, 呼び出し元関数にムーブされる.
}
```

- 所有権を取り, またその所有権を戻すということを全ての関数で行うのは煩雑. 関数に値は使わせるものの所有権を取らないようにさせるためには**参照**と呼ばれるものを使用する.