---
layout: default
title: "rust9"
date: 2025-06-04
use_mathjax: true
# categories:
---

# Rustメモ(9)

Rustの標準ライブラリにはコレクションと呼ばれるデータ構造がある。
ここでは、以下の代表的な３種について学ぶ。
- ベクタ型
- 文字型
- ハッシュマップ

## [8.1 ベクタで値のリストを保持する](https://doc.rust-jp.rs/book-ja/ch08-01-vectors.html)

- ベクタは複数の値をメモリ上に隣り合わせに並べる。
  - ベクタには同じ型の値しか保持できない。
- ベクタはジェネリクスを使用して実装されている。
- 空のベクタを作成する際は型注釈が必要。一方、値を含むベクタを作成する場合は、初期値から型が推論されるため、型注釈は不要。
- ベクタを生成し、要素を追加するためには `push` メソッドを用いる。
  - 値を変更する際はベクタを定義する際に `mut` キーワードをつけて可変にする必要あり。
- 構造体と同様に、ベクタもスコープを抜ければ要素含め解放される。

```rust
let v1: Vec<i32> = Vec::new(); // 空のベクタを作成する。型注釈が必要。

let v2 = vec![1, 2, 3]; // 値を含む新しいベクタの作成。型注釈不要

let mut v3 = Vec::new(); // 以降で要素を追加するため、可変にしておく。以降で追加される要素から型が推論されるため、型注釈は不要。

v3.push(5);
v3.push(6);
v3.push(7);
v3.push(8); // ベクタに要素が追加される。
```

- ベクタの要素を表す添字は0から始まる。
- ベクタの特定の要素を得る方法は以下の２つがある。
  - `&` と `[]` を使用して参照を得る。
    - 存在しない要素を参照する場合、プログラムをパニックさせる。
  - `get` メソッドに引数として添字を渡して `Option<&T>` を得る。
    - 存在しない要素を添字に渡すと、`None` を返す。

```rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2]; // 3番目の要素を参照
println!("The third element is {}", third);

match v.get(2) {
    Some(third) => println!("The third element is {}", third),
    None => println!("There is no third element."), // ベクタの範囲外の添字が`get`で指定された場合は`None`を返す
}

let does_not_exist = &v[100];  // パニックを起こす
```

- 同一スコープ内にて可変と不変な参照を同時には存在させられないルールはベクタ型でも適用される。

```rust
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];  // 不変参照

// 新たな要素をベクタの終端に追加するとき、
// いまベクタのある場所に全要素を隣り合わせに配置するだけのスペースがないなら、
// 古い要素を新しいスペースにコピーする必要がある。
v.push(6);

// 最初の要素を指す参照は、解放されたメモリを指すことになるが、
// 借用規則によりエラーが生じるようになっている（開放されたメモリを指してバグにならないようにしている）
println!("The first element is: {}", first);
```

- 添字で1要素毎にアクセスする方法の他にベクタの全要素を走査することができる。

```rust
let v1 = vec![100, 32, 57];
for i in &v1 { // ベクタの要素に順番にアクセスする
    println!("{}", i);
}

// ベクタが可変なら、可変参照が参照している値を変更することもできる
let mut v2 = vec![100, 32, 57];
for i in &mut v2 {
    *i += 50; // `+=` 演算子を使用する前に、参照外し演算子 `*` を使用して `i` の値にたどり着く必要がある。
}
```

- enumを用いて複数の型を保持したベクタを作成することができる。

```rust
// ベクタに格納しえる全ての型があらかじめ網羅できない場合には、この方法は使えない
// その場合は代わりにトレインオブジェクトが使用できる。
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

// enumに加えて`match`式を使うことで、あらゆるケースが処理できるようにすることも可能
let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```