---
layout: default
title: "rust1"
date: 2025-05-18
# use_mathjax: true
# categories:
---

# Rustメモ(1)

## [3.1 変数と可変性](https://doc.rust-jp.rs/book-ja/ch03-01-variables-and-mutability.html)

- 変数は不変. `let` を用いて以下の通り定義する.

```rust
fn main() {
    let x = 3;
    x = 4; // エラーが生じる
}
```

可変にするときは `mut` を用いる.

```rust
fn main() {
    let mut x = 3;
    x = 4; // xの値が更新される
}
```

- 定数は `const` を用いて定義する.

```rust
fn main() {
    const MAX_POINTS: u32 = 100_000;
}
```

定数を用いる際, 以下の事項に注意する.
    - 値の型は必ず注釈する.
    - どんなスコープでも定義できる.
    - 定数は定数式にしかセットできない.

- 変数は同じ名前の変数を新しく宣言でき, 新しい変数は前の変数を覆い隠す（シャドーイング）.

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x); // x = 12
    }

    println!("The value of x is: {}", x); // x = 6
}
```

シャドーイングと `mut` は異なる.
より具体的な違いは以下の2点.

1. `let` を用いずに変数に再代入を行うとコンパイルエラーが生じる.

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    x = 7; // エラーが生じる.
}
```

2. 値の方を変えつつ, 同じ変数名を使い回せる.

```rust
let spaces = "   "; // 文字型
let spacse = spaces.len(); // 数値型

let mut spaces = "   ";
spaces = spaces.len(); // コンパイルエラーになる
```

最後にエラーが生じるのは, 変数の型を可変にすることが許されていないためである. 

## [3.2 データ型](https://doc.rust-jp.rs/book-ja/ch03-02-data-types.html)

- Rustは静的型付き言語 = コンパイル時にすべての変数の方が判明している必要がある.
  - コンパイラは値と使用方法に基づいて, 使用したい型を推論する. 複数の型が推論される可能性がある場合, 型注釈をつける必要がある.

  ```rust
  // 具体例
  let guess: u32 = "42".parse().expect("Not a number!");    // 数字ではなく文字
  ``` 

### スカラー型

整数, 浮動小数点数, 論理値, 文字の4つがある.

- 整数：小数部分のない数値のこと
  - `isize`, `usize` はプログラムが動作しているコンピュータの種類に依存する.
  - 整数型の基準は `i32`

| 大きさ | 符号付き | 符号なし |
|:------|:-------|:--------|
| 8-bit | `i8` | `u8` |
| 16-bit | `i16` | `u16` |
| 32-bit | `i32` | `u32` |
| 64-bit | `i64` | `u64` |
| arch | `isize` | `usize` |

- 浮動小数点：数値に小数点がついたもの
  - `f32` と `f64` の2種類がある.
    - `f32` は単精度浮動小数点数
    - `f64` は倍精度浮動小数点数
  - 基準値は `f64`.

- 論理値型：`true` と `false` の二つ
  - Rustの論理値型は, `bool` と指定される.


### 複合型

複数の値を一つの方にまとめることができる. タプルと配列の2種類がある。

- タプル型
  - 丸括弧の中にカンマ区切りの値リストを書くことで生成する.
  - タプルの一毎に型があり, それぞれ全てが同じ型である必要はない.
  
  ```rust
  fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
  }
  ```
  
  - タプルから個々の値を取り出すには, パターンマッチングを使用して分解することができる.

  ```rust
  fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup; // 分配がなされているk

    println!("The value of y is: {}", y);
  }
  ```

  - アクセスしたい値の番号をピリオドに続けて書くことでタプルの要素に直接アクセスすることができる.
  
  ```rust
  fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0; // タプルの最初の添字は0

    let six_point_four = x.1;

    let one = x.2;
  }
  ```

- 配列型
  - 配列の全要素は同じ型である必要がある.
  - Rustの配列は固定長である.
    -  **ベクタ型**はサイズを伸縮させることができる
  - 配列は以下のときに有効
    - ヒープよりもスタックにデータのメモリを確保したい
    - 常に固定長の要素があることを確認したい
  - 配列はスタック上に確保される一塊のメモリ
  
  ```rust
  fn main() {
    let a = [1, 2, 3, 4, 5];

    let b = [1, "hoge"]; // 型が揃っていないのでエラー
  }
  ```
  
  - 初期化の仕方は以下の通り

  ```rust
  let a: [i32; 5] = [1, 2, 3, 4, 5]; // 要素の型と要素数を与える
  
  let a = [3; 5]; //let a = [3, 3, 3, 3, 3]; と同じ
  ```
  
  - 配列の要素には以下のようにアクセスする
  
  ```rust
  fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
    let error = a[10]; // 配列の長さを超えた添字にアクセスしようとするとコンパイルではエラーが生じないものの, 実行時エラー（パニック）が生じる
  }
  ```
